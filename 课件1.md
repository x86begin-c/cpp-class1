以下是第一份课件的详细内容，聚焦「C++类的基础定义与初始化」，包含核心知识点解析、代码实例、关键说明及练习，适配C++入门学习者：


# 第1份课件：C++类的基础定义与初始化  
**学习目标**：  
1. 理解C++类的概念及与结构体的区别  
2. 掌握类的定义语法（成员变量、成员函数的声明与定义）  
3. 学会创建对象（栈上/堆上实例化）并访问成员  
4. 掌握构造函数（默认、带参、拷贝）的定义与作用  
5. 理解析构函数的功能及调用时机  
6. 学会使用成员初始化列表优化初始化逻辑  


## 一、类的概念：从结构体到类  
在C语言中，`struct`（结构体）仅能包含**数据成员**（变量），无法封装**操作数据的函数**。C++为了实现「数据与操作的绑定」，扩展出`class`（类）—— 类可以同时包含**成员变量**（数据）和**成员函数**（操作），这是面向对象编程的核心基础。  

### 1.1 类与结构体的核心区别  
| 特性         | C++结构体（struct）       | C++类（class）           |  
|--------------|---------------------------|--------------------------|  
| 默认访问权限 | 成员默认`public`（公开）  | 成员默认`private`（私有）|  
| 核心用途     | 主要用于封装简单数据集合   | 用于完整的面向对象封装   |  

**示例：结构体与类的对比**  
```cpp
// C++结构体（默认public）
struct PointStruct {
    int x;  // 默认public，类外可直接访问
    int y;
    void print() {  // 结构体也可包含函数（C++扩展）
        cout << "(" << x << "," << y << ")" << endl;
    }
};

// C++类（默认private）
class PointClass {
    int x;  // 默认private，类外不可直接访问
    int y;
public:  // 显式声明public区域
    void print() {
        cout << "(" << x << "," << y << ")" << endl;
    }
};
```


## 二、类的定义：成员变量与成员函数  
类的定义需明确「数据（成员变量）」和「操作（成员函数）」，语法格式如下：  

```cpp
class 类名 {
    // 成员变量（数据）
    // 成员函数（操作）
};  // 注意：类定义结尾必须有分号
```

### 2.1 成员的声明与定义  
- **类内声明**：成员变量和成员函数的原型在类体中声明  
- **类外定义**：成员函数的实现可写在类外（需用`类名::`限定作用域）  


#### 示例：完整的类定义（以`Student`类为例）  
```cpp
#include <iostream>
#include <string>
using namespace std;

// 类的声明：包含成员变量和成员函数的原型
class Student {
    // 成员变量（默认private，仅类内可访问）
    string name;  // 姓名
    int id;       // 学号

public:  // 公开接口：类外可访问
    // 成员函数声明（类内）
    void setInfo(string n, int i);  // 设置学生信息
    void showInfo();                // 显示学生信息
};

// 成员函数定义（类外，需用Student::限定）
void Student::setInfo(string n, int i) {
    name = n;  // 访问类内成员变量，无需额外限定
    id = i;
}

void Student::showInfo() {
    cout << "姓名：" << name << "，学号：" << id << endl;
}
```

**关键说明**：  
- 成员变量通常设为`private`（隐藏数据），成员函数设为`public`（暴露操作接口），这是封装的基础。  
- 类外定义成员函数时，`类名::`不可省略，否则编译器会认为是普通全局函数。  


## 三、对象的创建与成员访问  
类是「模板」，对象是「模板实例化的具体实体」。创建对象后，通过成员访问运算符操作其成员。  

### 3.1 对象的两种创建方式  
| 创建方式 | 语法示例                  | 内存区域 | 生命周期               |  
|----------|---------------------------|----------|------------------------|  
| 栈上创建 | `Student s;`              | 栈内存   | 超出作用域自动销毁     |  
| 堆上创建 | `Student* p = new Student;` | 堆内存  | 需用`delete`手动销毁   |  


### 3.2 成员访问运算符  
- 对于**对象本身**：用 `.` 访问成员（`s.setInfo(...)`）  
- 对于**对象指针**：用 `->` 访问成员（`p->setInfo(...)`）  


#### 示例：创建对象并访问成员  
```cpp
int main() {
    // 1. 栈上创建对象
    Student s;
    s.setInfo("张三", 2023001);  // 用.访问成员函数
    s.showInfo();                // 输出：姓名：张三，学号：2023001

    // 2. 堆上创建对象（指针）
    Student* p = new Student;
    p->setInfo("李四", 2023002);  // 用->访问成员函数
    p->showInfo();                // 输出：姓名：李四，学号：2023002

    // 堆上对象必须手动释放，否则内存泄漏
    delete p;
    p = nullptr;  // 避免野指针

    return 0;
}
```


## 四、构造函数：对象的初始化  
对象创建时，需要初始化成员变量（如给`name`和`id`赋值）。构造函数是**特殊的成员函数**，专门用于对象初始化，其名称与类名相同，无返回值。  


### 4.1 构造函数的分类与定义  
#### （1）默认构造函数  
- 无参数的构造函数，若用户未定义，编译器会**自动生成默认构造函数**（仅做简单初始化）。  
- 一旦用户定义了其他构造函数，编译器不再生成默认构造函数，需手动定义。  

```cpp
class Student {
    string name;
    int id;
public:
    // 默认构造函数（无参数）
    Student() {
        name = "未知";
        id = 0;
    }
    // ... 其他成员函数
};
```


#### （2）带参构造函数  
- 有参数，可在创建对象时指定初始化值，灵活初始化成员变量。  

```cpp
class Student {
    string name;
    int id;
public:
    // 带参构造函数
    Student(string n, int i) {
        name = n;
        id = i;
    }
    // ... 其他成员函数
};
```

**调用方式**：  
```cpp
Student s1("王五", 2023003);  // 栈上对象：直接传参
Student* p1 = new Student("赵六", 2023004);  // 堆上对象：new时传参
```


#### （3）拷贝构造函数  
- 用于**用已有对象初始化新对象**（对象复制），参数必须是「同类对象的const引用」（避免递归调用）。  
- 若用户未定义，编译器会生成**默认拷贝构造函数**（浅拷贝：仅复制成员变量值）。  

```cpp
class Student {
    string name;
    int id;
public:
    // 拷贝构造函数（参数为const引用）
    Student(const Student& other) {
        name = other.name;  // 复制other的name
        id = other.id;      // 复制other的id
        cout << "拷贝构造函数被调用" << endl;
    }
    // ... 其他构造函数和成员函数
};
```

**调用场景**：  
```cpp
Student s2("钱七", 2023005);
Student s3 = s2;  // 用s2初始化s3，调用拷贝构造
Student s4(s2);   // 另一种调用方式，效果同上
```


## 五、析构函数：对象的清理  
析构函数是**对象销毁时自动调用的函数**，用于释放对象占用的资源（如堆内存、文件句柄等），语法为 `~类名()`，无参数，无返回值。  


### 5.1 析构函数的定义与作用  
```cpp
class Student {
    string name;
    int* score;  // 动态分配的分数数组（示例：需要手动释放的资源）
public:
    // 带参构造函数：分配堆内存
    Student(string n, int numScores) {
        name = n;
        score = new int[numScores];  // 动态分配数组
        cout << "构造函数：分配了" << numScores << "个分数的内存" << endl;
    }

    // 析构函数：释放堆内存
    ~Student() {
        if (score != nullptr) {
            delete[] score;  // 释放动态数组
            score = nullptr;
            cout << "析构函数：释放了分数数组的内存" << endl;
        }
    }
};
```

**调用时机**：  
- 栈上对象：作用域结束时自动调用（如函数返回、代码块结束）。  
- 堆上对象：`delete` 时调用。  


### 5.2 为什么需要自定义析构函数？  
- 编译器生成的默认析构函数**不会释放动态分配的资源**（如`new`的内存），会导致内存泄漏。  
- 自定义析构函数的核心作用：**清理对象生命周期中申请的资源**。  


## 六、成员初始化列表：更高效的初始化  
构造函数体内对成员变量的赋值（如`name = n`）本质是「先默认初始化，再赋值」，效率较低。**成员初始化列表**可在成员变量创建时直接初始化，效率更高。  


### 6.1 语法格式  
```cpp
类名(参数列表) : 成员变量1(值1), 成员变量2(值2), ... {
    // 构造函数体（可空）
}
```


### 6.2 示例：用初始化列表优化构造函数  
```cpp
class Student {
    string name;  // 字符串成员
    int id;       // 整数成员
    const int maxScore;  // const成员（必须初始化，不能赋值）
public:
    // 带参构造函数（用初始化列表）
    Student(string n, int i, int ms) : name(n), id(i), maxScore(ms) {
        // 构造函数体无需再赋值
    }
};
```

**关键说明**：  
- 初始化顺序**由成员变量在类中的声明顺序决定**，与列表中的顺序无关（避免依赖顺序的错误）。  
- `const`成员、引用成员（如`int& ref`）**必须通过初始化列表初始化**（不能在构造函数体内赋值）。  


## 七、综合实例：完整的`Student`类实现  
```cpp
#include <iostream>
#include <string>
using namespace std;

class Student {
    string name;  // 姓名（private）
    int id;       // 学号（private）
    int* scores;  // 成绩数组（动态分配，需释放）
    int numScores;// 成绩数量

public:
    // 1. 默认构造函数
    Student() : name("未知"), id(0), scores(nullptr), numScores(0) {
        cout << "默认构造函数被调用" << endl;
    }

    // 2. 带参构造函数（初始化列表）
    Student(string n, int i, int num) : name(n), id(i), numScores(num) {
        scores = new int[numScores];  // 分配成绩数组
        cout << "带参构造函数被调用，分配了" << numScores << "个成绩的内存" << endl;
    }

    // 3. 拷贝构造函数（深拷贝，避免浅拷贝导致的重复释放）
    Student(const Student& other) : name(other.name), id(other.id), numScores(other.numScores) {
        // 深拷贝：重新分配内存并复制数据（而非直接复制指针）
        scores = new int[numScores];
        for (int i = 0; i < numScores; i++) {
            scores[i] = other.scores[i];
        }
        cout << "拷贝构造函数被调用（深拷贝）" << endl;
    }

    // 4. 析构函数（释放资源）
    ~Student() {
        if (scores != nullptr) {
            delete[] scores;
            scores = nullptr;
            cout << "析构函数被调用，释放了成绩数组内存" << endl;
        }
    }

    // 成员函数：设置成绩
    void setScores(int* arr) {
        for (int i = 0; i < numScores; i++) {
            scores[i] = arr[i];
        }
    }

    // 成员函数：显示信息
    void showInfo() {
        cout << "姓名：" << name << "，学号：" << id << endl;
        cout << "成绩：";
        for (int i = 0; i < numScores; i++) {
            cout << scores[i] << " ";
        }
        cout << endl;
    }
};

// 主函数测试
int main() {
    // 测试带参构造
    int scores1[] = {90, 85, 95};
    Student s1("张三", 2023001, 3);
    s1.setScores(scores1);
    s1.showInfo();

    // 测试拷贝构造
    Student s2 = s1;  // 用s1初始化s2
    s2.showInfo();

    // 测试默认构造
    Student s3;
    s3.showInfo();  // 姓名：未知，学号：0（成绩未分配）

    return 0;  // 离开作用域，s1、s2、s3的析构函数依次被调用
}
```

**输出结果**：  
```
带参构造函数被调用，分配了3个成绩的内存
姓名：张三，学号：2023001
成绩：90 85 95 
拷贝构造函数被调用（深拷贝）
姓名：张三，学号：2023001
成绩：90 85 95 
默认构造函数被调用
姓名：未知，学号：0
成绩：
析构函数被调用，释放了成绩数组内存  // s3（无动态内存，仅输出提示）
析构函数被调用，释放了成绩数组内存  // s2
析构函数被调用，释放了成绩数组内存  // s1
```


## 八、练习题：设计`Array`类  
**需求**：实现一个动态数组类`Array`，包含以下功能：  
1. 成员变量：`int* data`（动态数组）、`int size`（数组大小）。  
2. 构造函数：  
   - 默认构造：初始化`size=0`，`data=nullptr`。  
   - 带参构造：接收`size`，动态分配数组并初始化为0。  
   - 拷贝构造：实现深拷贝（避免重复释放内存）。  
3. 析构函数：释放`data`指向的动态内存。  
4. 成员函数：`set(int index, int value)`（设置指定位置的值）、`print()`（打印数组元素）。  

**提示**：注意数组访问越界检查（可选），拷贝构造时需重新分配内存并复制数据。  


## 九、总结  
1. 类是包含成员变量和成员函数的模板，对象是类的实例化实体。  
2. 构造函数用于对象初始化（默认、带参、拷贝三种类型），析构函数用于资源清理。  
3. 堆上对象需用`delete`释放，否则会导致内存泄漏。  
4. 成员初始化列表比构造函数体内赋值更高效，尤其适用于`const`成员和引用成员。  

下一份课件将深入讲解「访问控制与封装」，进一步强化类的安全性设计。  


以下是第一份课件的7道课后作业，覆盖类的定义、对象创建、构造函数、析构函数、初始化列表等核心知识点，难度由基础到综合逐步提升：


## 课后作业  

#### 1. 基础类定义与对象创建  
定义一个`Rectangle`类，包含私有成员变量`length`（长）和`width`（宽），以及公有成员函数：  
- `setDimensions(double l, double w)`：设置长和宽（确保长和宽为正数，若为负数则设为0）；  
- `getArea()`：返回矩形面积（长×宽）；  
- `printInfo()`：打印“长：x，宽：y，面积：z”。  
在`main`函数中：  
- 栈上创建一个`Rectangle`对象，调用`setDimensions(3.5, 4.2)`，并打印信息；  
- 堆上创建一个`Rectangle`对象，调用`setDimensions(-2, 5)`（此时长应设为0），打印信息后用`delete`释放。  


#### 2. 带参构造函数的应用  
定义一个`Book`类，包含私有成员`title`（书名，`string`）、`author`（作者，`string`）、`price`（价格，`double`）。  
要求：  
- 定义**带参构造函数**，通过参数初始化`title`、`author`、`price`（价格需≥0，否则设为0）；  
- 定义`showBook()`成员函数，打印“书名：xxx，作者：xxx，价格：xxx”。  
在`main`函数中创建2个`Book`对象（分别用栈和堆方式），参数分别为`("C++ Primer", "Lippman", 89.0)`和`("无效书籍", "匿名", -20)`，调用`showBook()`验证结果。  


#### 3. 析构函数与堆内存管理  
定义一个`IntArray`类，功能：管理动态分配的int数组。  
私有成员：  
- `int* data`：指向动态数组的指针；  
- `int size`：数组大小。  
公有成员：  
- 带参构造函数`IntArray(int n)`：若`n>0`，则分配大小为`n`的数组并初始化为0；否则`data`设为`nullptr`，`size=0`；  
- 析构函数`~IntArray()`：若`data`非空，释放内存并打印“释放了大小为x的数组”；  
- `setValue(int index, int value)`：若`index`在有效范围（0~size-1），则设置`data[index] = value`；  
- `printArray()`：打印数组所有元素（如“[0, 1, 2]”）。  
在`main`函数中创建`IntArray arr(5)`，调用`setValue(0, 10)`、`setValue(2, 20)`，打印数组后观察析构函数是否自动调用。  


#### 4. 拷贝构造函数与深拷贝  
基于第3题的`IntArray`类，补充**拷贝构造函数**，实现深拷贝（即新对象的`data`指向新分配的内存，并复制原数组的数据）。  
验证要求：  
- 创建`IntArray arr1(3)`，调用`setValue(0, 1)`、`setValue(1, 2)`；  
- 用`IntArray arr2 = arr1`创建对象`arr2`，修改`arr2`的`data[0]`为100；  
- 分别打印`arr1`和`arr2`的数组，确保`arr1`的`data[0]`仍为1（证明深拷贝生效）；  
- 观察析构函数调用时是否正常释放（无重复释放崩溃）。  


#### 5. 成员初始化列表的使用  
定义一个`Circle`类，包含私有成员：  
- `double radius`（半径）；  
- `const double PI`（圆周率，固定为3.14159）；  
- `string color`（颜色）。  
要求：  
- 定义带参构造函数`Circle(double r, string c)`，**必须使用成员初始化列表**初始化`PI`、`radius`、`color`（半径需≥0，否则设为0）；  
- 定义`getArea()`：返回圆面积（`PI×radius²`）；  
- 定义`printCircle()`：打印“颜色：xxx，半径：xxx，面积：xxx”。  
在`main`函数中创建`Circle`对象，参数为`(5.0, "红色")`和`(-3.0, "蓝色")`，验证初始化结果。  


#### 6. 跟踪构造与析构函数的调用顺序  
分析以下代码的输出结果，写出完整输出并解释原因（可手动模拟或实际运行验证）：  
```cpp
#include <iostream>
using namespace std;

class Test {
public:
    Test() { cout << "默认构造" << endl; }
    Test(int x) { cout << "带参构造：" << x << endl; }
    Test(const Test& other) { cout << "拷贝构造" << endl; }
    ~Test() { cout << "析构函数" << endl; }
};

void func(Test t) { /* 空函数 */ }

int main() {
    Test t1;                  // 语句1
    Test t2(10);              // 语句2
    Test t3 = t2;             // 语句3
    func(t3);                 // 语句4
    Test* t4 = new Test(20);  // 语句5
    delete t4;                // 语句6
    return 0;
}
```


#### 7. 综合应用题：设计`Date`类  
定义一个`Date`类，管理年、月、日。  
私有成员：`int year, month, day`。  
公有成员：  
1. 默认构造函数：初始化日期为`2000年1月1日`；  
2. 带参构造函数`Date(int y, int m, int d)`：通过初始化列表初始化，需简单校验合法性（月份1-12，日期1-当月最大天数，此处简化：每月最多31天，非法则设为1）；  
3. 拷贝构造函数：复制年、月、日；  
4. `printDate()`：打印“yyyy年mm月dd日”（如“2023年05月03日”，注意补0）；  
5. `setDate(int y, int m, int d)`：修改日期（同样校验合法性）。  
在`main`函数中：  
- 用默认构造创建`d1`，打印；  
- 用`Date(2024, 2, 30)`创建`d2`（2月30日非法，应改为2月1日），打印；  
- 用`d2`拷贝构造`d3`，修改`d3`为`2024年2月29日`，分别打印`d2`和`d3`；  
- 堆上创建`d4`，参数为`(2025, 13, -5)`，打印后释放。  


### 作业说明  
- 第1-5题侧重单一知识点练习，需独立编写类的完整代码（包含类定义、成员函数实现、`main`函数测试）；  
- 第6题需理解构造/析构函数的调用时机（如函数传参时拷贝构造的调用、堆对象`delete`时析构的调用）；  
- 第7题为综合应用，需结合构造函数、拷贝构造、初始化校验等知识点，培养实际类设计能力。  

可根据代码运行结果验证正确性，重点关注内存是否泄漏（堆对象是否用`delete`释放）、深拷贝是否生效、初始化逻辑是否符合预期。